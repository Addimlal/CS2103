{"name":"CS2103","tagline":"Compilerbau (CB)","body":"Compilerbau (CB) - Programmieraufgabe CS2103\r\n==================\r\n\r\nProblemstellung\r\n---------------\r\n\r\nProgrammierung des Codegenerators sowie gruendliches\r\nTesten aller Module des Compilers im Zusammenspiel.\r\n\r\n\r\nVorgegebene Dateien\r\n-------------------\r\n\r\nREADME          -  die Beschreibung, die Sie gerade lesen\r\nmain.c          -  das Hauptprogramm des entstehenden Compilers\r\ncodegen.h       -  Interface zum Codegenerator\r\ncodegen.c       -  der Codegenerator: das ist Ihre Aufgabe\r\n\r\n\r\nAufgaben\r\n--------\r\n\r\nZunaechst ein Hinweis: Der Code, den Ihr Compiler erzeugt, muss in\r\nkeiner Hinsicht so aussehen, wie der Code der Referenzimplementierung.\r\nSie duerfen sich zwar gerne diesen Code ansehen; versuchen Sie aber\r\nnicht, unter allen Umstaenden gleichen Code zu erzeugen. Wichtigstes\r\nZiel in dieser Phase ist korrekter Code, d.h. Code, der genau das\r\nVerhalten zeigt, das laut Sprachdefinition von ihm gefordert wird.\r\n\r\n1. Programmieren Sie einen rekursiven Durchgang durch die abstrakte\r\n   Syntax. Sie koennen zur Vereinfachung der folgenden Aufgabenteile\r\n   an jedem besuchten Knoten einen kurzen String ausgeben, der den\r\n   Knotentyp benennt (in Postorder-Reihenfolge). Wenn Sie diesen als\r\n   Assembler-Kommentar (eingeleitet mit einem Semikolon) \"tarnen\",\r\n   kann Ihre Ausgabe sogar in der erzeugten Assembler-Ausgabedatei\r\n   stehen bleiben.\r\n\r\n2. Ergaenzen Sie nun die Traversierungsfunktionen der einzelnen\r\n   Knotentypen um die Ausgabe von ECO32-Assemblercode. Entwerfen\r\n   Sie zunaechst jeweils ein ganz kurzes SPL-Programm, das den\r\n   ins Auge gefassten Knotentyp beim Uebersetzen produziert (so\r\n   etwas sollte eigentlich aus Loesungen zu frueher gestellten\r\n   Aufgaben schon zur Verfuegung stehen). Programmieren Sie dann\r\n   die Codegenerierung fuer diesen Knotentyp. Pruefen Sie zuletzt,\r\n   ob der erzeugte Code fuer Ihr SPL-Programm korrekt ist.\r\n   Hier ist ein Vorschlag fuer die Reihenfolge der Knotentypen:\r\n   - StmList (ausser dem rekursiven Abstieg ist hier nichts zu tun)\r\n   - IntExp\r\n   - OpExp (nur Arithmetik, keine Vergleiche)\r\n   - SimpleVar (ohne Beruecksichtigung von Referenzvariablen)\r\n   - VarExp\r\n   - AssignStm\r\n   - ArrayVar (nicht vergessen: Indexgrenzen-Ueberpruefung, s.u.)\r\n   - WhileStm\r\n   - OpExp (nur Vergleiche, keine Arithmetik)\r\n   - IfStm\r\n   - CallStm (ohne Beruecksichtigung von Referenzvariablen)\r\n   - ProcDec mit folgenden Teilaufgaben:\r\n     Framegroesse berechnen\r\n     Prozedur-Prolog ausgeben\r\n     Code fuer Prozedurkoerper erzeugen\r\n     Prozedur-Epilog ausgeben\r\n   Hinweise:\r\n   - Falls die Indexgrenzen-Ueberpruefung fehlschlaegt, lassen\r\n     Sie den Code zum Label \"_indexError\" verzweigen. Das ist eine\r\n     Bibliotheksfunktion, die das Programm mit einer Fehlermeldung\r\n     abbricht.\r\n   - Denken Sie an die Ueberpruefung, ob genuegend Register\r\n     fuer Hilfsvariable zur Verfuegung stehen. Brechen Sie die\r\n     Uebersetzung ggf. mit einer geeigneten Fehlermeldung ab.\r\n\r\n3. Untersuchen Sie, an welcher Stelle ein Programm, das Referenz-\r\n   variablen benutzt, noch fehlerhaft ist. Ergaenzen Sie den Code-\r\n   generator so, dass auch SPL-Programme mit Referenzvariablen\r\n   richtig uebersetzt werden.\r\n\r\n4. Ueberzeugen Sie sich von der Korrektheit des erzeugten Codes\r\n   fuer die etwas groesseren Testprogramme (Queens, Sierpinski,\r\n   Sortieren eines Arrays).\r\n\r\n5. Glueckwunsch: Ihr SPL-Compiler ist fertig!","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}